#! /usr/bin/env python
import logging
import random
import pickle
import os
import sys
import getopt

# Import PDFRW later for controling the logging format.
# Note: The original pdfw should be used in parsing the repacked seeds for efficiency.
# No, we have to use the modified version, due to the additional trace issue.



import os
import copy
import hashlib
import logging

from xmlrpclib import ServerProxy
import time
import os
import sys

_current_dir = os.path.abspath(os.path.dirname(__file__))
PROJECT_ROOT = os.path.normpath(os.path.join(_current_dir, ".."))
sys.path.append(PROJECT_ROOT)

from lib.config import config
HOST = config.get('detector_agent', 'host')
PORT = int(config.get('detector_agent', 'port'))

RPC_SERVER_ADDR = "http://%s:%d" % (HOST, PORT)

def query_classifier(classifier_name, file_paths, seed_sha1 = False):
    file_paths = map(os.path.abspath, file_paths)
    server = ServerProxy(RPC_SERVER_ADDR)
    results = None
    while not results:
        # try:
        results = server.query_classifier(classifier_name, file_paths, seed_sha1)
     
        return results

def setup_logging(log_file_path):
    logging.basicConfig(filename=log_file_path,
                        filemode='a',
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                        level=logging.DEBUG,
                        )

LOW_SCORE = -65535

finished_flag = "evaded.flag"
visited_flag = "dev.log"
result_flag = "fitness_%.2f.flag"
error_flag = "error.flag"

# Make the order of file list deterministic.
def list_file_paths(dir_name, size_limit=None):
    fnames = os.listdir(dir_name)
    fnames.sort()

    ret = [os.path.join(dir_name, fname) for fname in fnames]
    if size_limit:
        return ret[:size_limit]
    else:
        return ret

def touch(fname):
    try:
        os.utime(fname, None)
    except:
        open(fname, 'a').close()

def deepcopy(obj):
    return copy.deepcopy(obj)

def hash_file(filepath):
    sha1 = hashlib.sha1()
    f = open(filepath, 'rb')
    try:
        sha1.update(f.read())
    finally:
        f.close()
    return sha1.hexdigest()




logger = logging.getLogger('gp.fitness')

def fitness_pos_neg(file_paths, seed_sha1, classifier_name, oracle_name, offset = 0):
    classifier = lambda *args:query_classifier(classifier_name, *args)
    oracle = lambda *args:query_classifier(oracle_name, *args)

    classified_scores = classifier(file_paths)
    oracle_results = oracle(file_paths, seed_sha1)

    while oracle_results == None or classified_scores == None:
        print("Invalid results: oracle %s classifier %s " % (oracle_results != None, classified_scores != None))
        classified_scores = classifier(file_paths)
        oracle_results = oracle(file_paths, seed_sha1)

    for i in range(len(file_paths)):
        short_path = '/'.join(file_paths[i].split('/')[-3:])
        print("Variant: %s %s %s" % (oracle_results[i], classified_scores[i], short_path))

    fitness_scores = []
    for i in range(len(classified_scores)):
        if oracle_results[i] == 'malicious':
            score = (classified_scores[i]-offset) * float(-1)
        else:
            # big negative fitness
            score = LOW_SCORE
        fitness_scores.append(score)
    return fitness_scores

def fitness_01(file_paths, seed_sha1, classifier_name, oracle_name):
    return fitness_pos_neg(file_paths, seed_sha1, classifier_name, oracle_name, offset = 0.5)

def fitness_pdfrate(file_paths, seed_sha1):
    return fitness_01(file_paths, seed_sha1, 'pdfrate', 'cuckoo')



import math

def sigmoid(x):
    return 1 / (1 + math.exp(-x))

def mean(x):
    return sum(x)/float(len(x))

import operator
def geo_mean(iterable):
    return (reduce(operator.mul, iterable)) ** (1.0/len(iterable))


    p_scores = pdfrate(file_paths)
    #h_scores = hidost(file_paths)
    #h_scores = map(sigmoid, h_scores)
    oracle_results = oracle(file_paths, seed_sha1)

    #assert (len(p_scores) == len(h_scores) == len(oracle_results) == len(file_paths))
    assert (len(p_scores)  == len(oracle_results) == len(file_paths))

    fitness_scores = []
    for i in range(len(file_paths)):
        short_path = '/'.join(file_paths[i].split('/')[-3:])
        p_score, h_score, oracle_result = p_scores[i], h_scores[i], oracle_results[i]

        if oracle_result == 'malicious':
            classify_score = [p_score, h_score]
            score = -mean(classify_score)
            if max(classify_score) < 0.5:
                score += 0.5
        else:
            # big negative fitness
            score = LOW_SCORE
        print("Variant: %s %.2f %.2f %.2f %s" % (oracle_result, score, p_score, h_score, short_path))
        fitness_scores.append(score)
    return fitness_scores

class GPPdf:

    def fitness( *args):
        return fitness_func(*args)

    def run():
        print("Start a gp task with %s" % (gp_params))
        
        score_file_name = os.path.join(job_dir, "fitness_scores.pickle")
        fitness_scores = {}
        
        popul = initial_population()
        generation = 1

        while generation <= max_gen:
            print("There're %d variants in population at generation %d." % (len(popul), generation))

            file_paths = save_variants_to_files()

            scores = fitness(file_paths, seed_sha1)

            fitness_scores[generation] = scores
            pickle.dump(fitness_scores, open(score_file_name, 'wb'))
            
            print("Fitness scores: %s" % scores)
            print("Sorted fitness: %s" % sorted(scores, reverse=True))
            
            if max(scores) > fitness_threshold:
                best_score = max(scores)
                print("Already got a high score [%.2f]>%.2f variant, break the GP process." % (max(scores), fitness_threshold))
                
                # Store the success traces.
                for i in range(len(scores)):
                    score = scores[i]
                    if score > fitness_threshold:
                        success_trace = popul[i].active_trace
                        success_traces.append(success_trace)

                # Dump the new generated traces.
                # We assume no concurrent GP tasks depending on the traces.
                Trace.dump_traces(success_traces, success_traces_path)
                touch(os.path.join(job_dir, finished_flag))
                break
            elif generation == max_gen:
                print("Failed at max generation.")
                if max(scores) >= seed_fitness:
                    best_gen, best_vid, best_score = get_best_variant(1, generation)
                    promising_trace = load_variant_trace(best_gen, best_vid)

                    print("Save the promising trace %.2f of %d:%d" % (best_score, best_gen, best_vid))

                    promising_traces.append(promising_trace)
                    Trace.dump_traces(promising_traces, promising_traces_path, exclude_traces=success_traces)
                break

            # Crossover
            if xover_rate > 0:
                popul = select(popul, scores, pop_size/2)
                print("After selecting goods and replacing bads, we have %d variants in population." % len(popul))

                for p1,p2 in zip(popul[0::2], popul[1::2]):
                    c1, c2 = PdfGenome.crossover(p1, p2)
                    popul.append(c1)
                    popul.append(c2)
                print("After crossover, we have %d variants in population." % len(popul))
            else: # No Crossover
                popul = select(popul, scores, pop_size)
                print("After selecting goods and replacing bads, we have %d variants in population." % len(popul))

            # Mutation
            for i in range(len(popul)):
                if i not in vid_from_trace:
                    print("Generating %d:%d variant" % (generation+1, i))
                    popul[i] = PdfGenome.mutation(popul[i], mut_rate, ext_genome)
                else:
                    print("Keep %d:%d variant from trace." % (generation+1, i))

            generation = generation + 1

        print("Stopped the GP process with max fitness %.2f." % best_score)
        touch(os.path.join(job_dir, result_flag % best_score))
        return True

    def initial_population(self):
        logger = logger
        print("Getting initial population from existing mutation traces (success: %d, promising: %d)." \
                    % (len(success_traces), len(promising_traces)))
        popul = []

        traces = success_traces + promising_traces
        traces = Trace.get_distinct_traces(traces)
        print("Got %d distinct traces" % len(traces))
        traces = traces

        remaining_traces_id = range(len(traces))

        if 0 < len(remaining_traces_id) <= pop_size:
            tid_picked = remaining_traces_id
        elif len(remaining_traces_id) > pop_size:
            tid_picked = random.sample(remaining_traces_id, pop_size)
            tid_picked.sort()
        else:
            tid_picked = []

        # generate_variants_from_traces
        for i in tid_picked:
            remaining_traces_id.remove(i)
            print("Generating %d variant from existing trace." % i)
            trace = traces[i]
            variant_root = Trace.generate_variant_from_trace(seed_root, trace, ext_genome)
            popul.append(variant_root)

        if len(popul) < int(pop_size):
            print("Getting %d more variants in initial population by random mutation." \
                        % (int(pop_size) - len(popul)))

        while len(popul) < int(pop_size):
            i = len(popul)
            print("Getting variant %d in initial population." % i)
            root = deepcopy(seed_root)
            root = PdfGenome.mutation(root, mut_rate, ext_genome)
            popul.append(root)
        return popul

    def get_best_variant(self, start_gen, end_gen):
        best_gen = 1
        best_vid = 0
        best_score = LOW_SCORE
        for gen in range(start_gen, end_gen+1):
            scores = fitness_scores[gen]
            if max(scores) > best_score:
                best_score = max(scores)
                best_gen = gen
                best_vid = scores.index(best_score)
        return best_gen, best_vid, best_score

    def select(self, orig_list, scores, sel_size):
        # when reverse==False, select variants with lower score, otherwise select higher scores.
        sorted_indices = [i[0] for i in sorted(enumerate(scores), key=lambda x:x[1], reverse=True)]
        
        ret = []
        vid_from_trace = []
        
        for i in sorted_indices[:sel_size]:
            if scores[i] == LOW_SCORE:
                if len(remaining_traces_id) > 0:
                    # TODO: need to label these, not to mutate in next generation.
                    vid_from_trace.append(i)
                    tid_picked = random.choice(remaining_traces_id)
                    remaining_traces_id.remove(tid_picked)
                    print("Ignored a variant with low score, generating from existing trace %d" % tid_picked)
                    trace = traces[tid_picked]
                    new_variant = Trace.generate_variant_from_trace(seed_root, trace, ext_genome)
                    ret.append(new_variant)

                elif generation == 1:
                    print("Ignored a variant with low score, replace with original seed.")
                    ret.append(deepcopy(seed_root))
                else:
                    choice = random.choice(['seed', 'last_gen_best', 'historic_best'])
                    if choice == "seed":
                        print("Ignored a variant with low score, replace with original seed.")
                        ret.append(deepcopy(seed_root))
                    elif choice == "last_gen_best":
                        best_gen, best_vid, best_score = get_best_variant(generation-1, generation-1)
                        best_root =  load_variant(best_gen, best_vid)
                        ret.append(best_root)
                        print("Ignored a variant with low score, replace with best variant in last generation[%d, %d]." % (best_gen, best_vid))
                    elif choice == "historic_best":
                        best_gen, best_vid, best_score = get_best_variant(1, generation-1)
                        best_root =  load_variant(best_gen, best_vid)
                        ret.append(best_root)
                        print("Ignored a variant with low score, replace with best variant in historic generation[%d, %d]." % (best_gen, best_vid))
            else:
                print("Selected a file with score %.2f" % scores[i])
                ret.append(orig_list[i])
        
        return ret

def get_opt(argv):
    classifier_name = None
    start_file = None
    ext_genome_folder = None
    pop_size = None
    max_gen = None
    mut_rate = None
    xover_rate = 0
    stop_fitness = None
    random_state_file_path = None
    token = None
    round_id = 1

    help_msg = "gp.py -c <classifier name> -o <oracle name> \
        -s <start file location> -e <external genome folder> \
        -p <population size> -g <max generation> \-m <mutation rate> \
        -x <crossvoer rate> -r <random_state_file_path> -t <task_token>\
        --round <round_id>\
        -f <stop criterion in fitness score>"
    
    if len(argv) < 2:
        print help_msg
        sys.exit(2)

    try:
        opts, args = getopt.getopt(argv[1:],"hc:s:e:p:g:m:f:x:r:t:",["classifier=",
                                                                 "sfile=",
                                                                 "extgenome=",
                                                                 "popu=",
                                                                 "gen=",
                                                                 "mut=",
                                                                 "fitness=",
                                                                 "crossover=",
                                                                 "random_state=",
                                                                 "token=",
                                                                 "round=",
                                                                 ])
    except getopt.GetoptError:
        print help_msg
        sys.exit(2)

    for opt, arg in opts:
        if opt == '-h':
            print help_msg
            sys.exit()
        elif opt in ("-c", "--classifier"):
            classifier_name = arg
        elif opt in ("-s", "--sfile"):
            start_file = arg
        elif opt in ("-e", "--extgenome"):
            ext_genome_folder = arg
        elif opt in ("-p", "--popu"):
            pop_size = int(arg)
        elif opt in ("-g", "--gen"):
            max_gen = int(arg)
        elif opt in ("-m", "--mut"):
            mut_rate = float(arg)
        elif opt in ("-x", "--crossover"):
            xover_rate = float(arg)
        elif opt in ("-f", "--fitness"):
            stop_fitness = float(arg)
        elif opt in ("-r", "--random_state"):
            random_state_file_path = arg
        elif opt in ("-t", "--token"):
            token = arg
        elif opt in("--round"):
            round_id = int(arg)
    
    if xover_rate != 0 and pop_size % 4 != 0:
        print "The population size should be times of 4."
        sys.exit(2)

    print classifier_name, start_file, ext_genome_folder, \
        pop_size, max_gen, mut_rate, xover_rate, \
        stop_fitness, random_state_file_path, token, round_id

    return classifier_name, start_file, ext_genome_folder, \
        pop_size, max_gen, mut_rate, xover_rate, \
        stop_fitness, random_state_file_path, token, round_id

if __name__ == "__main__":
    classifier_name, start_file_path, \
        ext_genome_folder, pop_size, max_gen, mut_rate, \
        xover_rate, stop_fitness, random_state_file_path, \
        task_token, round_id = get_opt(sys.argv)

    start_hash = os.path.basename(start_file_path).split('.')[0]

    for rid in range(1, round_id + 1):
        job_dir = "./results/%s/log_r%d/classifier=%s,mut=%.1f,xover=%.1f,popsz=%d,maxgen=%d,stopfit=%.2f,start=%s" \
                    % (task_token, rid, classifier_name, mut_rate, xover_rate, pop_size, max_gen, stop_fitness, start_hash)
        if not os.path.isdir(job_dir):
            os.makedirs(job_dir)

        # skip the succeeded tasks in previous rounds.
        # skip all the visited tasks in the current round.
        if os.path.exists(os.path.join(job_dir, finished_flag)):
            sys.exit(0)
        if rid == round_id and os.path.exists(os.path.join(job_dir, visited_flag)):
            sys.exit(0)

    traces_dir = "./results/%s/trace/" % task_token
    if not os.path.isdir(traces_dir):
        os.makedirs(traces_dir)
    success_traces_path = traces_dir + "success_traces.pickle"
    promising_traces_path = traces_dir + "promising_traces.pickle"

    log_file_path = os.path.join(job_dir, visited_flag)
    setup_logging(log_file_path)
    logger = logging.getLogger('gp.core')
    print("Starting logging for a GP process...")

    # Due to logging is called in pdfrw, they have to be imported after basicConfig of logging.
    # Otherwise, the above basicConfig would be overridden.
    from lib.pdf_genome import PdfGenome
    from lib.trace import Trace

    if classifier_name == 'pdfrate':
        from lib.fitness import fitness_pdfrate as fitness_func

    gp_params = {'pop_size': pop_size, 'max_gen': max_gen, \
             'mut_rate': mut_rate, 'xover_rate': xover_rate, \
             'fitness_threshold': stop_fitness}
    ext_genome = PdfGenome.load_external_genome(ext_genome_folder)

    try:
        gp = GPPdf( job_dir = job_dir,
                    seed_sha1 = start_hash,
                    seed_file_path = start_file_path,
                    logger = logger,
                    random_state_file_path = random_state_file_path,
                    ext_genome = ext_genome,
                    success_traces_path = success_traces_path,
                    promising_traces_path = promising_traces_path,
                    gp_params = gp_params,
                    fitness_function = fitness_func,
                    )
        gp.run()
    except Exception, e:
        touch(os.path.join(job_dir, error_flag))
        logger.exception(e)
        sys.exit(1)
